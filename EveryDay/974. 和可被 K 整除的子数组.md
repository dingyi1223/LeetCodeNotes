## [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

`20200527`

`难度：中等`

### 题目描述

给定一个整数数组 `A`，返回其中元素之和可被 `K` 整除的（连续、非空）子数组的数目。

**示例：**

```
输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]
```

**提示：**

1. `1 <= A.length <= 30000`
2. `-10000 <= A[i] <= 10000`
3. `2 <= K <= 10000`

### Solution

看到子数组和——想到**前缀和**

和 [560. 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)类似

这里的【前缀和】指的是：**和%K**

因为`(pre[j]-pre[i-1]) mod K == 0`

即`pre[j] mod K == pre[i-1] mod K`

```java
class Solution {
    public int subarraysDivByK(int[] A, int K) {
        Map<Integer, Integer> preSumFreq = new HashMap<>();
        int modK = 0;
        int count = 0;
        int sum = 0;
        preSumFreq.put(0, 1);//[前缀和 mod K = 0]已经出现 1 次
        for(int num : A){
            sum += num;
            // modK = sum % K;
            modK = (sum % K + K) % K;
            if(preSumFreq.containsKey(modK)){
                count += preSumFreq.get(modK);
            }
            preSumFreq.put(modK, preSumFreq.getOrDefault(modK, 0) + 1);
        }
        return count;
    }
}
```

要注意是取余的求法，Java中负数取模：当被除数为负数时取模结果为负数，需要纠正

负数参与的取模运算规则：先忽略负号，按照正数运算之后，被取模的数是正数结果就取正，反之取负。