## [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

`20200730`

`难度：中等`

### 题目描述

给定一个正整数 *n*，将其拆分为**至少**两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

**示例 1:**

```matlab
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```matlab
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

**说明:** 你可以假设 *n* 不小于 2 且不大于 58。

### Soluiton

动态规划

- 状态：`dp[i]`代表和为i的时候，可以获得的最大乘积。答案返回`dp[n]`。

- 状态转移：取最后一个数字为k。对于每一个状态而言，还要再比较“不再继续分割”和“继续分割：分成k和i-k；分成k和(i-k)的分解结果，两者取最大。

  `dp[i] = max(k * (i - k), dp[i-k] * k)`

  这里`(i - k)`不包括在`dp[i-k] `里的原因是：题目说是**至少**两个正整数，循环里条件里也是`k < i`

```java
class Solution {
    public int integerBreak(int n) {
        //dp[i]代表和为i的时候，可以获得的最大乘积
        int[] dp = new int[n + 1];
        for(int i = 1; i <= n; i++){
            dp[i] = 1;//乘积最小是1*1*1...
            for(int k = 1; k < i; k++){
                //分成k和i-k；分成k和(i-k)的分解结果。取最大。
                dp[i] = Math.max(Math.max(dp[i], k * (i-k)), dp[i-k] * k);
            }
        }
        return dp[n];
    }
}
```

